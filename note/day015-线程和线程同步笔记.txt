day016线程和线程同步笔记


1. 线程Thread类
	1.1. 进程：简单的理解进程就是正在运行的一个应用程序
	1.2. 线程: 就是进程的最小执行单位，是一个独立的功能。
	
	1.3. 多线程作用：
			为了利用计算机的多核心优势
 *			提高程序运行效率
 ------------------------------------（重点）--------------------------------------------

 *	1.4 多线程使用：（重点）
 		 语法：
 *				1. 继承Thread类	（重点掌握）
 *					步骤：
 *					1. 写一个线程类XxxThread extends Thread类
 *					2. 重写run()方法（该方法是业务方法，启动线程后，会自动执行该方法）
 *					3. 写一个测试类，在测试类中创建线程子类对象，调用对象的start()启动线程
 
 *				2. 实现Runnable接口	（重点掌握）	
 *					1. 写一个实现业务类XxxRunnableImpl implements Runnable接口
 *					2. 重写run()方法（该方法是业务方法，启动线程后，会自动执行该方法）
 *					3. 写一个测试类，在测试类中
 *						先创建业务类对象，再创建线程对象，并且将业务类对象作为参数传入线程的构造方法中，
 						调用线程对象的start()启动线程
 * 
 *				
 	1.5 线程的注意事项：
 		1. 只有start方法才是启动线程，run方法只是在执行方法。
 		2. 同一个线程对象，start方法不能多次调用。
 		3. 以后都用实现Runnable接口的方式，因为Java中单继承多实现，实现的扩展性强
 	
 	1.6 线程的常用方法：(掌握)
 		1. 构造方法：
			Thread() 创建一个新的 Thread对象。  
			Thread(String name) 创建一个新的有指定线程名的 Thread对象。  
			Thread(Runnable target)  将Runnable业务类对象作为参数，创建一个新的 Thread对象。    
			Thread(Runnable target, String name) 将Runnable业务类对象作为参数，创建一个新的有指定线程名的 Thread对象。  
 
 		2. 普通方法：
			1. static Thread currentThread() 返回对当前正在执行的线程对象的引用。  
			2. String getName() 返回此线程的名称。 
			3. void setName(String name) 设置线程对象的名字   
			4. void setPriority(int newPriority)   设置线程对象的优先级
			5. int getPriority()  获取线程的优先级
				1-10，越大优先级越高，执行越早，越小就执行越晚
				5是默认优先级。
				当前线程的优先级与创建线程对象的环境的优先级一致
				
			6. boolean isDaemon() 判断这个线程是否是守护线程。  GC是守护线程
				一个线程的默认状态和创建它的环境线程状态一致	
			
			7. void setDaemon(boolean on) 将当前线程设置为守护线程   
				活跃的线程不能设置为守护线程
			8. static void sleep(long millis)  阻塞当前线程指定的毫秒数后再执行
				一般用来模拟网络延迟，可以做计时器，还可以做倒计时
				
			9. void join() 等待join线程执行完后，再执行当前线程【理解】
			10. void join(long millis)等待join线程线程死亡最多 millis毫秒。  【理解】
				
 	1.7 线程扩展（线程状态、了解）
 		1.7.1、新建（new）：线程对象被创建后就进入了新建状态。如：Thread thread = new Thread();

		1.7.2、就绪状态（Runnable）：也被称为“可执行状态”。线程对象被创建后，其他线程调用了该对象的start()方法，
			从而启动该线程。如：thread.start(); 处于就绪状态的线程随时可能被CPU调度执行。
		
		1.7.3、运行状态（Running）：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。
		
		1.7.4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权限，暂时停止运行。
			直到线程进入就绪状态，才有机会进入运行状态。阻塞的三种情况：
		
		    1）等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。
		
		    2）同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。
		
		    3）其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。
			当sleep()状态超时、join()等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。
	
		1.7.5、死亡状态（Dead）：线程执行完了或因异常退出了run()方法，该线程结束生命周期。
 	
 ------------------------------------（重点）--------------------------------------------
 	1.8 线程同步方式：（重点）
 			为什么要线程同步？
				为了保证多线程情况下，数据的安全和逻辑合理性
				
				第一种：悲观锁（自己扩展）
					1. 同步代码块（重点掌握）
						语法：
							synchronized(同步对象) {// 必须是几个线程对象所共享的 => static
								有线程安全问题的代码
							}	
							同步对象可以是：static修饰的对象、字节码、this(实现Runnable接口)
						
					2. 同步方法（重点掌握）
						用synchronized关键字修饰方法即可，在修饰符位置，返回值前面
						如果方法是static修饰的：同步的是 :当前类.class 
						如果方法是非static修饰的：同步的是: this 
						
						如果继承Thread的方式，同步方法的话，就需要将方法改为static修饰，所以说，一般我们不用同步方法
						一般建议继承Thread用同步代码块或者锁机制
						
				第二种：乐观锁（自己扩展）（重点掌握）
					锁机制: Lock接口的实现类ReentrantLock【可重入互斥锁】
						构造方法：
							1. ReentrantLock() 创建一个 ReentrantLock的实例。   不要公平机制。效率高
							2. ReentrantLock(boolean fair) 根据给定的公平政策创建一个 ReentrantLock的实例。 
								 理论上获取锁的几率是相同的
						 class X {
						   private final ReentrantLock lock = new ReentrantLock();
						
						   public void m() { 
						     lock.lock();  // 上锁
						     try {
						       	// 有线程安全问题的代码
						     } finally {
						       lock.unlock();// 释放锁
						     }
						   }
						 }
					
					
		7. 同步对象：只要这个对象只有一份
			1. static修饰的对象只有一份，在静态区
			2. 字节码文件 Xxx.class文件只有一份，在元空间【建议使用当前类的字节码文件】
			3. this也可以只有一份，只要创建一个对象this就是一个
		
		8. 线程同步注意事项：（重点掌握）
			1. 使用选择：
				锁机制效率高且功能更加强大，建议使用
				同步方法简单，如果能够满足性能要求建议使用同步方法
			
			2. 同步对象：必须保证几个线程对象共享的是同一个同步对象（一般使用当前类的字节码文件或者this）
			
			3. 锁原则：最小范围原则，为了保证执行效率
 
 
 	1.9 线程扩展2（线程池、线程通信、高频面试题：死锁、以及锁的种类）了解
 
 
 
 